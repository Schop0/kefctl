#!/usr/bin/perl
#
# Copyright (C) 2020, Sebastian Riedel.
#
# This program is free software, you can redistribute it and/or modify it under
# the terms of the Artistic License version 2.0
#
use strict;
use warnings;
use 5.10.1;

use Getopt::Long 'GetOptions';
use IO::Socket::INET;

use constant DEBUG => $ENV{KEFDSP_DEBUG} || 0;

our $VERSION = '0.1';

my $GET_MODE      = "\x47\x27\x80\x40";
my $GET_DESK_DB   = "\x47\x28\x80\x92";
my $GET_WALL_DB   = "\x47\x29\x80\x92";
my $GET_TREBLE_DB = "\x47\x2a\x80\x40";
my $GET_HIGH_HZ   = "\x47\x2b\x80\x40";
my $GET_LOW_HZ    = "\x47\x2c\x80\x40";
my $GET_SUB_DB    = "\x47\x2d\x80\x40";

# TODO: Add flags for setting all the bits in the 532781XX frame (decoding is
# already finished in speaker status)
# wall mode:      532781ad
# desk mode:      532781ae
# desk+wall mode: 532781af
# neither:        532781ac

my $DESK_WALL_DB = [
  '-6.0', '-5.5', '-5.0', '-4.5', '-4.0', '-3.5', '-3.0', '-2.5',
  '-2.0', '-1.5', '-1.0', '-0.5', '0'
];
my $TREBLE_DB
  = ['-2.0', '-1.5', '-1.0', '-0.5', '0', '+0.5', '+1.0', '+1.5', '+2.0'];
my $HIGH_HZ = [50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120];
my $LOW_HZ  = [
  40,  45,  50,  55,  60,  65,  70,  75,  80,  85,  90,  95,
  100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155,
  160, 165, 170, 175, 180, 185, 190, 195, 200, 205, 210, 215,
  120, 225, 230, 235, 240, 245, 250
];
my $SUB_DB = [
  '-10.0', '-9.0', '-8.0', '-7.0', '-6.0', '-5.0', '-4.0', '-3.0',
  '-2.0',  '-1.0', '0',    '+1.0', '+2.0', '+3.0', '+4.0', '+5.0',
  '+6.0',  '+7.0', '+8.0', '+9.0', '+10.0'
];

Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case));
GetOptions
  'd|desk=s'      => \my $desk,
  'g|sub-gain=s'  => \my $gain,
  'h|help'        => \my $help,
  'H|host=s'      => \(my $host = '192.168.178.66'),
  'i|high-pass=s' => \my $high,
  'l|low-pass=s'  => \my $low,
  'p|port=s'      => \(my $port = 50001),
  'r|request=s'   => \my $request,
  's|status'      => \my $status,
  't|treble=s'    => \my $treble,
  'version'       => \my $version,
  'W|wall=s'      => \my $wall;

# Usage
if ($help) { _usage() }

# Version
elsif ($version) { say "kefdsp $VERSION" }

# Arbitrary request in hex (for testing)
elsif ($request) { say unpack 'H*', _command(pack('H*', $request)) }

# Desk
elsif (defined $desk) { _slider("\x28", $DESK_WALL_DB, $desk) }

# Wall
elsif (defined $wall) { _slider("\x29", $DESK_WALL_DB, $wall) }

# Treble
elsif (defined $treble) { _slider("\x2a", $TREBLE_DB, $treble) }

# High-pass
elsif (defined $high) { _slider("\x2b", $HIGH_HZ, $high) }

# Low-pass
elsif (defined $low) { _slider("\x2c", $LOW_HZ, $low) }

# Sub gain
elsif (defined $gain) { _slider("\x2d", $SUB_DB, $gain) }

elsif ($status) {
  my $mode_bits = unpack 'B*', substr(_command($GET_MODE), 3, 1);
  warn "*** MODE: $mode_bits\n" if DEBUG;
  my $desk_mode        = substr($mode_bits, 7, 1) ? 'On' : 'Off';
  my $wall_mode        = substr($mode_bits, 6, 1) ? 'On' : 'Off';
  my $phase_correction = substr($mode_bits, 5, 1) ? 'On' : 'Off';
  my $high_pass        = substr($mode_bits, 4, 1) ? 'On' : 'Off';
  my $sub_polarity     = substr($mode_bits, 1, 1) ? '-'  : '+';

  my $sub_ext_bits = substr($mode_bits, 2, 2);
  my $sub_ext      = 'Unknown';
  if    ($sub_ext_bits eq '00') { $sub_ext = 'Standard' }
  elsif ($sub_ext_bits eq '10') { $sub_ext = 'Less' }
  elsif ($sub_ext_bits eq '01') { $sub_ext = 'Extra' }

  my $desk_db_int = unpack 'C', substr(_command($GET_DESK_DB), 3, 1);
  my $desk_db     = $DESK_WALL_DB->[$desk_db_int - 128] // 'Unknown';

  my $wall_db_int = unpack 'C', substr(_command($GET_WALL_DB), 3, 1);
  my $wall_db     = $DESK_WALL_DB->[$wall_db_int - 128] // 'Unknown';

  my $treble_db_int = unpack 'C', substr(_command($GET_TREBLE_DB), 3, 1);
  my $treble_db     = $TREBLE_DB->[$treble_db_int - 128] // 'Unknown';

  my $high_hz_int = unpack 'C', substr(_command($GET_HIGH_HZ), 3, 1);
  my $high_hz     = $HIGH_HZ->[$high_hz_int - 128] // 'Unknown';

  my $low_hz_int = unpack 'C', substr(_command($GET_LOW_HZ), 3, 1);
  my $low_hz     = $LOW_HZ->[$low_hz_int - 128] // 'Unknown';

  my $sub_db_int = unpack 'C', substr(_command($GET_SUB_DB), 3, 1);
  my $sub_db     = $SUB_DB->[$sub_db_int - 128] // 'Unknown';

  say "Desk mode:        $desk_mode ($desk_db dB)";
  say "Wall mode:        $wall_mode ($wall_db dB)";
  say "Treble trim:      $treble_db dB";
  say "Phase correction: $phase_correction";
  say "High-pass mode:   $high_pass ($high_hz Hz)";
  say "Sub out low-pass: $low_hz Hz";
  say "Sub gain:         $sub_db dB";
  say "Sub polarity:     $sub_polarity";
  say "Bass extension:   $sub_ext";
}

# Usage
else { _usage() }

sub _command {
  my $req = shift;

  state $sock = IO::Socket::INET->new(
    PeerHost => $host,
    PeerPort => $port,
    Type     => SOCK_STREAM,
  ) or die "Cannot construct socket: $@";

  warn "*** REQ: @{[unpack 'H*', $req]}\n" if DEBUG;
  $sock->syswrite($req) or die "Cannot write command: $!";
  die "Could not read command response: $!"
    unless defined(my $read = $sock->sysread(my $res, 1024, 0));
  warn "*** RES: @{[unpack 'H*', $res]}\n" if DEBUG;

  return $res;
}

sub _find_val {
  my ($array, $val) = @_;

  my $target;
  for my $i (0 .. $#$array) {
    next unless $val eq $array->[$i];
    $target = 128 + $i;
    last;
  }

  return $target;
}

sub _slider {
  my ($op, $array, $val) = @_;
  die "Unknown value: $val\n" unless my $to = _find_val($array, $val);
  _command("\x53$op\x81" . pack('C', $to));
}

sub _usage {
  say <<'EOF';
Usage: kefdsp [OPTIONS]

    kefdsp -d -3.5
    kefdsp -w -6.0
    kefdsp -t 0
    kefdsp -high-pass 95
    kefdsp -l 80
    kefdsp -H 192.168.178.52 -p 50001 -g +5.0
    kefdsp -r 5330819b0b

  Options:
    -d, --desk <db>        Set dB value for desk mode, between 0 and -6.0 in
                           steps of 0.5
    -g, --sub-gain <db>    Set dB value for sub gain, between -10.0 and +10.0 in
                           steps of 1.0
    -h, --help             Show this summary of available options
    -H, --host <host>      Speaker host, defaults to 192.168.178.66
    -i, --high-pass <hz>   Set Hz value for high-pass mode, between 50 and 120
                           in steps of 5
    -l, --low-pass <hz>    Set Hz value for sub out low-pass, between 40 and 250
                           in steps of 5
    -p, --port <port>      Speaker port, defaults to 50001
    -r, --request <hex>    Send raw request in hex format and show response
                           (very useful for testing speaker features)
    -s, --status           Show current speaker status
        --version          Show version
    -t, --treble <db>      Set dB value for treble trim, between -2.0 and +2.0
                           in steps of 0.5.
    -w, --wall <db>        Set dB value for wall mode, between 0 and -6.0 in
                           steps of 0.5

  You can also set the KEFCTL_DEBUG environment variable to get diagnostics
  information printed to STDERR.
EOF
}
