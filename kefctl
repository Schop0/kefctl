#!/usr/bin/perl
#
# Copyright (C) 2019, Sebastian Riedel.
#
# This program is free software, you can redistribute it and/or modify it under
# the terms of the Artistic License version 2.0
#
use strict;
use warnings;
use 5.10.1;

use Getopt::Long 'GetOptions';
use IO::Socket::INET;

use constant DEBUG => $ENV{KEFCTL_DEBUG} || 0;

our $VERSION = '1.01';

# The commands could be easily generated by code, but for now i prefer to keep
# tables, to make it easier to spot new patters in the protocol and figure out
# more features
my $GET_VOLUME = "\x47\x25\x80\x6c";
my $GET_SOURCE = "\x47\x30\x80\xd9";
my $OFF        = "\x53\x30\x81\x9b\x0b";
my $MUTE       = "\x53\x25\x81\xda\x5f";
my $INPUT      = {
  aux => {
    0  => ["\x53\x30\x81\x2a\x00", "\x53\x30\x81\x6a\x00"],
    20 => ["\x53\x30\x81\x0a\x00", "\x53\x30\x81\x4a\x00"],
    60 => ["\x53\x30\x81\x1a\x00", "\x53\x30\x81\x5a\x00"]
  },
  bluetooth => {
    0  => ["\x53\x30\x81\x29\x00", "\x53\x30\x81\x69\x00"],
    20 => ["\x53\x30\x81\x09\x00", "\x53\x30\x81\x49\x00"],
    60 => ["\x53\x30\x81\x19\x00", "\x53\x30\x81\x59\x00"]
  },
  optical => {
    0  => ["\x53\x30\x81\x2b\x00", "\x53\x30\x81\x6b\x00"],
    20 => ["\x53\x30\x81\x0b\x00", "\x53\x30\x81\x4b\x00"],
    60 => ["\x53\x30\x81\x1b\x00", "\x53\x30\x81\x5b\x00"]
  },
  wifi => {
    0  => ["\x53\x30\x81\x22\x00", "\x53\x30\x81\x62\x00"],
    20 => ["\x53\x30\x81\x02\x00", "\x53\x30\x81\x42\x00"],
    60 => ["\x53\x30\x81\x12\x00", "\x53\x30\x81\x52\x00"]
  }
};

Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case));
GetOptions
  'h|help'      => \my $help,
  'H|host=s'    => \(my $host = '192.168.178.52'),
  'i|input=s'   => \my $input,
  'I|inverse'   => \my $inverse,
  'm|mute'      => \my $mute,
  'o|off'       => \my $off,
  'p|port=s'    => \(my $port = 50001),
  'r|request=s' => \my $request,
  's|standby=i' => \(my $standby = 60),
  'S|status'    => \my $status,
  'v|volume=i'  => \my $volume;
_usage() if $help;

# Arbitrary request in hex (for testing)
if ($request) { say unpack 'H*', _command(pack('H*', $request)) }

# Set input source and standby mode
elsif ($input) {
  die "Unknown input: $input\n"          unless my $modes = $INPUT->{lc $input};
  die "Unknown standby mode: $standby\n" unless my $table = $modes->{$standby};
  _command($table->[$inverse ? 1 : 0]);
}

# Set volume
elsif (defined $volume) {
  my $byte = pack 'H*', sprintf('%02x', $volume);
  _command("\x53\x25\x81$byte\x1a");
}

# Mute
elsif ($mute) { _command($MUTE) }

# Turn off
elsif ($off) { _command($OFF) }

# Status information (still need to figure out more)
elsif ($status) {

  my $volume = unpack 'C', substr(_command($GET_VOLUME), 3, 1);
  my $muted = $volume > 100 ? 'Yes' : 'No';
  say "Volume:  $volume%";
  say "Muted:   $muted";

  my $source_bits = unpack 'B*', substr(_command($GET_SOURCE), 3, 1);
  warn "*** SRC: $source_bits\n" if DEBUG;
  my $power   = substr($source_bits, 0, 1) ? 'Off' : 'On';
  my $inverse = substr($source_bits, 1, 1) ? 'Yes' : 'No';

  my $standby_bits = substr($source_bits, 2, 2);
  my $standby      = 'Unknown';
  if    ($standby_bits eq '00') { $standby = '20 Minutes' }
  elsif ($standby_bits eq '01') { $standby = '60 Minutes' }
  elsif ($standby_bits eq '10') { $standby = 'Never' }

  my $input_bits = substr($source_bits, 4, 4);
  my $input      = 'Unknown';
  if    ($input_bits eq '0010') { $input = 'Wifi' }
  elsif ($input_bits eq '1001') { $input = 'Bluetooth' }
  elsif ($input_bits eq '1111') { $input = 'Bluetooth' }
  elsif ($input_bits eq '1010') { $input = 'Aux' }
  elsif ($input_bits eq '1011') { $input = 'Optical' }

  say "Source:  $input";
  say "Standby: $standby";
  say "Inverse: $inverse";
  say "Power:   $power";
}

# Usage
else { _usage() }

sub _command {
  my $req = shift;

  state $sock = IO::Socket::INET->new(
    PeerHost => $host,
    PeerPort => $port,
    Type     => SOCK_STREAM,
  ) or die "Cannot construct socket: $@";

  warn "*** REQ: @{[unpack 'H*', $req]}\n" if DEBUG;
  $sock->syswrite($req) or die "Cannot write command: $!";
  die "Could not read command response: $!"
    unless defined(my $read = $sock->sysread(my $res, 1024, 0));
  warn "*** RES: @{[unpack 'H*', $res]}\n" if DEBUG;

  return $res;
}

sub _usage {
  say <<'EOF';
Usage: kefctl [OPTIONS]

    kefctl -S
    kefctl -v 70
    kefctl --off
    kefctl -i optical
    kefctl -i bluetooth -s 20 -I
    kefctl -H 192.168.178.52 -p 50001 -i aux
    kefctl -r 5330819b0b

  Options:
    -h, --help                  Show this summary of available options
    -H, --host <host>           Speaker host, defaults to 192.168.178.52
    -i, --input <source>        Set input source to aux, bluetooth, optical or
                                wifi
    -I, --inverse               Inverse L/R speakers, this option can only be
                                used together with the --input option
    -m, --mute                  Mute speakers, the speakers can be unmuted by
                                setting a new volume with the --volume option
    -o, --off                   Turn speakers off, the KEF LSX can be turned
                                back on by setting an input source with the
                                --input option
    -p, --port <port>           Speaker port, defaults to 50001
    -r, --request <hex>         Send raw request in hex format and show response
                                (very useful for testing speaker features)
    -s, --standby <minutes>     Set standby time to 20, 60 or 0 (to turn standby
                                off), this option can only be used together with
                                the --input option
    -S, --status                Show current speaker status
    -v, --volume <percentage>   Set volume to a percentage value of 0-100, be
                                aware that every input source has its own volume
                                setting

  You can also set the KEFCTL_DEBUG environment variable to get diagnostics
  information printed to STDERR.
EOF
  exit 0;
}
