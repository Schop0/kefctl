#!/usr/bin/perl
#
# Copyright (C) 2019, Sebastian Riedel.
#
# This program is free software, you can redistribute it and/or modify it under
# the terms of the Artistic License version 2.0
#
use strict;
use warnings;
use 5.10.1;

use Getopt::Long 'GetOptions';
use IO::Socket::INET;

use constant DEBUG => $ENV{KEFCTL_DEBUG} || 0;

our $VERSION = '1.0';

# The commands could be easily generated by code, but for now i prefer to keep
# tables, to make it easier to spot new patters in the protocol and figure out
# more features
my $GET_VOLUME  = "\x47\x25\x80\x6c";
my $GET_SOURCE  = "\x47\x30\x80\xd9";
my $GET_STANDBY = "\x47\x30\x80\xd9";
my $OFF         = "\x53\x30\x81\x9b\x0b";
my $MUTE        = "\x53\x25\x81\xda\x5f";
my $INPUT       = {
  aux => {
    0  => ["\x53\x30\x81\x2a\x9b", "\x53\x30\x81\x6a\x9b"],
    20 => ["\x53\x30\x81\x0a\x9b", "\x53\x30\x81\x4a\x9b"],
    60 => ["\x53\x30\x81\x1a\x9b", "\x53\x30\x81\x5a\x9b"]
  },
  bluetooth => {
    0  => ["\x53\x30\x81\x29\xad", "\x53\x30\x81\x69\xad"],
    20 => ["\x53\x30\x81\x09\xad", "\x53\x30\x81\x49\xad"],
    60 => ["\x53\x30\x81\x19\xad", "\x53\x30\x81\x59\xad"]
  },
  optical => {
    0  => ["\x53\x30\x81\x2b\x00", "\x53\x30\x81\x6b\x00"],
    20 => ["\x53\x30\x81\x0b\x00", "\x53\x30\x81\x4b\x00"],
    60 => ["\x53\x30\x81\x1b\x00", "\x53\x30\x81\x5b\x00"]
  },
  wifi => {
    0  => ["\x53\x30\x81\x22\x82", "\x53\x30\x81\x62\x82"],
    20 => ["\x53\x30\x81\x02\x82", "\x53\x30\x81\x42\x82"],
    60 => ["\x53\x30\x81\x12\x82", "\x53\x30\x81\x52\x82"]
  }
};

Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case));
GetOptions
  'h|help'      => \my $help,
  'H|host=s'    => \(my $host = '192.168.178.52'),
  'i|input=s'   => \my $input,
  'I|inverse'   => \my $inverse,
  'm|mute'      => \my $mute,
  'o|off'       => \my $off,
  'p|port=s'    => \(my $port = 50001),
  'r|request=s' => \my $request,
  's|standby=i' => \(my $standby = 60),
  'S|status'    => \my $status,
  'v|volume=i'  => \my $volume;
_usage() if $help;

# Arbitrary request in hex (for testing)
if ($request) { say unpack 'H*', _command(pack('H*', $request)) }

# Set input source and standby mode
elsif ($input) {
  die "Unknown input: $input\n"          unless my $modes = $INPUT->{lc $input};
  die "Unknown standby mode: $standby\n" unless my $table = $modes->{$standby};
  _command($table->[$inverse ? 1 : 0]);
}

# Set volume
elsif (defined $volume) {
  my $byte = pack 'H*', sprintf('%02x', $volume);
  _command("\x53\x25\x81$byte\x1a");
}

# Mute
elsif ($mute) { _command($MUTE) }

# Turn off
elsif ($off) { _command($OFF) }

# Status information (still need to figure out more)
elsif ($status) {

  my $volume = _status($GET_VOLUME);
  say "Volume:  $volume%";
  my $muted = $volume > 100 ? 'Yes' : 'No';
  say "Muted:   $muted";

  my $source  = _status($GET_SOURCE);
  my $sources = {
    2   => ['Wifi',      '20 Minutes', 'No'],
    9   => ['Bluetooth', '20 Minutes', 'No'],
    10  => ['Aux',       '20 Minutes', 'No'],
    11  => ['Optical',   '20 Minutes', 'No'],
    15  => ['Bluetooth', '20 Minutes', 'No'],
    18  => ['Wifi',      '60 Minutes', 'No'],
    25  => ['Bluetooth', '60 Minutes', 'No'],
    26  => ['Aux',       '60 Minutes', 'No'],
    27  => ['Optical',   '60 Minutes', 'No'],
    31  => ['Bluetooth', '60 Minutes', 'No'],
    34  => ['Wifi',      'Never',      'No'],
    41  => ['Bluetooth', 'Never',      'No'],
    42  => ['Aux',       'Never',      'No'],
    43  => ['Optical',   'Never',      'No'],
    47  => ['Bluetooth', 'Never',      'No'],
    66  => ['Wifi',      '20 Minutes', 'Yes'],
    73  => ['Bluetooth', '20 Minutes', 'Yes'],
    74  => ['Aux',       '20 Minutes', 'Yes'],
    75  => ['Optical',   '20 Minutes', 'Yes'],
    79  => ['Bluetooth', '20 Minutes', 'Yes'],
    82  => ['Wifi',      '60 Minutes', 'Yes'],
    89  => ['Bluetooth', '60 Minutes', 'Yes'],
    90  => ['Aux',       '60 Minutes', 'Yes'],
    91  => ['Optical',   '60 Minutes', 'Yes'],
    95  => ['Bluetooth', '60 Minutes', 'Yes'],
    98  => ['Wifi',      'Never',      'Yes'],
    105 => ['Bluetooth', 'Never',      'Yes'],
    106 => ['Aux',       'Never',      'Yes'],
    107 => ['Optical',   'Never',      'Yes'],
    111 => ['Bluetooth', 'Never',      'Yes'],
  };
  $source = $sources->{$source} || ['Unknown', 'Unknown', 'Unknown'];
  say "Input:   $source->[0]";
  say "Standby: $source->[1]";
  say "Inverse: $source->[2]";
}

# Usage
else { _usage() }

sub _command {
  my $req = shift;

  state $sock = IO::Socket::INET->new(
    PeerHost => $host,
    PeerPort => $port,
    Type     => SOCK_STREAM,
  ) or die "Cannot construct socket: $@";

  warn "*** REQ: @{[unpack 'H*', $req]}\n" if DEBUG;
  $sock->syswrite($req) or die "Cannot write command: $!";
  die "Could not read command response: $!"
    unless defined(my $read = $sock->sysread(my $res, 1024, 0));
  warn "*** RES: @{[unpack 'H*', $res]}\n" if DEBUG;

  return $res;
}

sub _status {
  my $command = shift;
  return hex substr unpack('H*', _command($command)), 6, 2;
}

sub _usage {
  say <<'EOF';
Usage: kefctl [OPTIONS]

    kefctl -S
    kefctl -v 70
    kefctl --off
    kefctl -i optical
    kefctl -i bluetooth -s 20 -I
    kefctl -H 192.168.179.52 -p 50001 -i aux
    kefctl -r 5330819b0b

  Options:
    -h, --help                  Show this summary of available options
    -H, --host <host>           Speaker host, defaults to 192.169.178.52
    -i, --input <source>        Set input source to aux, bluetooth, optical or
                                wifi
    -I, --inverse               Inverse L/R speakers, this option can only be
                                used together with the --input option
    -m, --mute                  Mute speakers, the speakers can be unmuted by
                                setting a new volume with the --volume option
    -o, --off                   Turn speakers off, the KEF LSX can be turned
                                back on by setting an input source with the
                                --input option
    -p, --port <port>           Speaker port, defaults to 50001
    -r, --request <hex>         Send raw request in hex format and show response
                                (very useful for testing speaker features)
    -s, --standby <minutes>     Set standby time to 20, 60 or 0 (to turn standby
                                off), this option can only be used together with
                                the --input option
    -S, --status                Show current speaker status
    -v, --volume <percentage>   Set volume to a percentage value of 0-100, be
                                aware that every input source has its own volume
                                setting

  You can also set the KEFCTL_DEBUG environment variable to get diagnostics
  information printed to STDERR.
EOF
  exit 0;
}
