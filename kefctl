#!/usr/bin/perl
#
# Copyright (C) 2019, Sebastian Riedel.
#
# This program is free software, you can redistribute it and/or modify it under
# the terms of the Artistic License version 2.0
#
use strict;
use warnings;
use 5.10.1;

use Getopt::Long 'GetOptions';
use IO::Socket::INET;

use constant DEBUG => $ENV{KEFCTL_DEBUG} || 0;

# The commands could be easily generated by code, but for now i prefer to keep
# tables, to make it easier to spot new patters in the protocol and figure out
# more features
my $GET_VOLUME  = "\x47\x25\x80\x6c";
my $GET_SOURCE  = "\x47\x30\x80\xd9";
my $GET_STANDBY = "\x47\x30\x80\xd9";
my $OFF         = "\x53\x30\x81\x9b\x0b";
my $MUTE        = "\x53\x25\x81\xda\x5f";
my $INPUT       = {
  aux => {
    0  => "\x53\x30\x81\x2a\x9b",
    20 => "\x53\x30\x81\x0a\x9b",
    60 => "\x53\x30\x81\x1a\x9b"
  },
  bluetooth => {
    0  => "\x53\x30\x81\x29\xad",
    20 => "\x53\x30\x81\x09\xad",
    60 => "\x53\x30\x81\x19\xad"
  },
  optical => {
    0  => "\x53\x30\x81\x2b\x00",
    20 => "\x53\x30\x81\x0b\x00",
    60 => "\x53\x30\x81\x1b\x00"
  },
  wifi => {
    0  => "\x53\x30\x81\x22\x82",
    20 => "\x53\x30\x81\x02\x82",
    60 => "\x53\x30\x81\x12\x82"
  }
};

Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case));
GetOptions
  'h|help'      => \my $help,
  'H|host=s'    => \(my $host = '192.168.178.52'),
  'i|input=s'   => \my $input,
  'm|mute'      => \my $mute,
  'o|off'       => \my $off,
  'p|port=s'    => \(my $port = 50001),
  'r|request=s' => \my $request,
  's|standby=i' => \(my $standby = 60),
  'S|status'    => \my $status,
  'v|volume=i'  => \my $volume;
_usage() if $help;

# Arbitrary request in hex (for testing)
if ($request) { say unpack 'H*', _command(pack('H*', $request)) }

# Set input source and standby mode
elsif ($input) {
  die "Unknown input: $input\n"          unless my $modes = $INPUT->{lc $input};
  die "Unknown standby mode: $standby\n" unless my $req   = $modes->{$standby};
  _command($req);
}

# Set volume
elsif (defined $volume) {
  my $byte = pack 'H*', sprintf('%02x', $volume);
  _command("\x53\x25\x81$byte\x1a");
}

# Mute
elsif ($mute) { _command($MUTE) }

# Turn off
elsif ($off) { _command($OFF) }

# Status information (still need to figure out more)
elsif ($status) {

  my $volume = _status($GET_VOLUME);
  say "Volume:  $volume%";
  my $muted = $volume > 100 ? 'Yes' : 'No';
  say "Muted:   $muted";

  my $source  = _status($GET_SOURCE);
  my $sources = {
    2  => ['Wifi',      '20 Minutes'],
    9  => ['Bluetooth', '20 Minutes'],
    10 => ['Aux',       '20 Minutes'],
    11 => ['Optical',   '20 Minutes'],
    15 => ['Bluetooth', '20 Minutes'],
    18 => ['Wifi',      '60 Minutes'],
    25 => ['Bluetooth', '60 Minutes'],
    26 => ['Aux',       '60 Minutes'],
    27 => ['Optical',   '60 Minutes'],
    31 => ['Bluetooth', '60 Minutes'],
    34 => ['Wifi',      'Never'],
    41 => ['Bluetooth', 'Never'],
    42 => ['Aux',       'Never'],
    43 => ['Optical',   'Never'],
    47 => ['Bluetooth', 'Never'],
  };
  $source = $sources->{$source} || ['Unknown', 'Unknown'];
  say "Input:   $source->[0]";
  say "Standby: $source->[1]";
}

# Usage
else { _usage() }

sub _command {
  my $req = shift;

  state $sock = IO::Socket::INET->new(
    PeerHost => $host,
    PeerPort => $port,
    Type     => SOCK_STREAM,
  ) or die "Cannot construct socket: $@";

  warn "*** REQ: @{[unpack 'H*', $req]}\n" if DEBUG;
  $sock->syswrite($req) or die "Cannot write command: $!";
  die "Could not read command response: $!"
    unless defined(my $read = $sock->sysread(my $res, 1024, 0));
  warn "*** RES: @{[unpack 'H*', $res]}\n" if DEBUG;

  return $res;
}

sub _status {
  my $command = shift;
  return hex substr unpack('H*', _command($command)), 6, 2;
}

sub _usage {
  say <<'EOF';
Usage: kefctl [OPTIONS]

    ./kefctl -v 70
    ./kefctl --off
    ./kefctl -i optical
    ./kefctl -i bluetooth -s 20
    ./kefctl -H 192.168.179.52 -p 50001 -i aux
    ./kefctl -r 5330819b0b

  Options:
    -h, --help                  Show this summary of available options
    -H, --host <host>           Speaker host, defaults to 192.169.178.52
    -i, --input <source>        Set input source to aux, bluetooth, optical or
                                wifi
    -m, --mute                  Mute speakers, the speakers can be unmuted by
                                setting a new volume with the --volume option
    -o, --off                   Turn speakers off, the KEF LSX can be turned
                                back on by setting an input source with the
                                --input option
    -p, --port <port>           Speaker port, defaults to 50001
    -r, --request <hex>         Send raw request in hex format and show response
                                (very useful for testing speaker features)
    -s, --standby <minutes>     Set standby time to 20, 60 or 0 (to turn standby
                                off), this option can only be used together with
                                the --input option
    -S, --status                Show current speaker status
    -v, --volume <percentage>   Set volume to a percentage value of 0-100, be
                                aware that every input source has its own volume
                                setting

  You can also set the KEFCTL_DEBUG environment variable to get diagnostics
  information printed to STDERR.
EOF
  exit 0;
}
