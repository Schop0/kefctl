#!/usr/bin/perl
#
# Copyright (C) 2019-2020, Sebastian Riedel.
#
# This program is free software, you can redistribute it and/or modify it under
# the terms of the Artistic License version 2.0
#
use strict;
use warnings;
use 5.10.1;

use File::Spec;
use Getopt::Long 'GetOptions';
use IO::Socket::INET;

use constant DEBUG => $ENV{KEFCTL_DEBUG} || 0;

our $VERSION = '1.09';

# The commands could be easily generated by code, but for now i prefer to keep
# tables, to make it easier to spot new patters in the protocol and figure out
# more features
my $GET_VOLUME = "\x47\x25\x80\x6c";
my $GET_SOURCE = "\x47\x30\x80\xd9";
my $OFF        = "\x53\x30\x81\x9b";
my $INPUT      = {
  aux => {
    0  => ["\x53\x30\x81\x2a", "\x53\x30\x81\x6a"],
    20 => ["\x53\x30\x81\x0a", "\x53\x30\x81\x4a"],
    60 => ["\x53\x30\x81\x1a", "\x53\x30\x81\x5a"]
  },
  bluetooth => {
    0  => ["\x53\x30\x81\x29", "\x53\x30\x81\x69"],
    20 => ["\x53\x30\x81\x09", "\x53\x30\x81\x49"],
    60 => ["\x53\x30\x81\x19", "\x53\x30\x81\x59"]
  },
  optical => {
    0  => ["\x53\x30\x81\x2b", "\x53\x30\x81\x6b"],
    20 => ["\x53\x30\x81\x0b", "\x53\x30\x81\x4b"],
    60 => ["\x53\x30\x81\x1b", "\x53\x30\x81\x5b"]
  },
  usb => {
    0  => ["\x53\x30\x81\x2c", "\x53\x30\x81\x6c"],
    20 => ["\x53\x30\x81\x0c", "\x53\x30\x81\x4c"],
    60 => ["\x53\x30\x81\x1c", "\x53\x30\x81\x5c"]
  },
  wifi => {
    0  => ["\x53\x30\x81\x22", "\x53\x30\x81\x62"],
    20 => ["\x53\x30\x81\x02", "\x53\x30\x81\x42"],
    60 => ["\x53\x30\x81\x12", "\x53\x30\x81\x52"]
  }
};

# Config file
my $HOST = '192.168.178.42';
if (-r (my $config = File::Spec->catfile($ENV{HOME}, '.kefctl'))) {
  open my $fh, '<', $config or die "Can't open file: $!";
  $HOST = <$fh>;
  chomp $HOST;
}

Getopt::Long::Configure(qw(default no_auto_abbrev no_ignore_case));
GetOptions
  'h|help'      => \my $help,
  'H|host=s'    => \$HOST,
  'i|input=s'   => \my $input,
  'I|inverse'   => \my $inverse,
  'L|lower=i'   => \my $lower,
  'm|mute'      => \my $mute,
  'o|off'       => \my $off,
  'p|port=s'    => \(my $port = 50001),
  'r|request=s' => \my $request,
  'R|raise=i'   => \my $raise,
  's|status'    => \my $status,
  'S|standby=i' => \(my $standby = 60),
  'u|unmute'    => \my $unmute,
  'v|volume=i'  => \my $volume,
  'version'     => \my $version;

# Usage
if ($help) { _usage() }

# Version
elsif ($version) { say "kefctl $VERSION" }

# Arbitrary request in hex (for testing)
elsif ($request) { say unpack 'H*', _command(pack('H*', $request)) }

# Set input source, standby mode and inverse mode
elsif ($input) {
  die "Unknown input: $input\n"          unless my $modes = $INPUT->{lc $input};
  die "Unknown standby mode: $standby\n" unless my $table = $modes->{$standby};
  _command($table->[$inverse ? 1 : 0]);
}

# Set volume
elsif (defined($volume) && $volume >= 0 && $volume <= 100) {
  _set_volume($volume);
}

# Raise volume
elsif ($raise) {
  my $target = _get_volume() + $raise;
  _set_volume($target > 100 ? 100 : $target);
}

# Lower volume
elsif ($lower) {
  my $target = _get_volume() - $lower;
  _set_volume($target < 0 ? 0 : $target);
}

# Mute
elsif ($mute) {
  my $current = _get_volume();
  _set_volume($current + 128) if $current <= 128;
}

# Unmute
elsif ($unmute) {
  my $current = _get_volume();
  _set_volume($current - 128) if $current >= 128;
}

# Turn off
elsif ($off) { _command($OFF) }

# Status information (should be complete)
elsif ($status) {

  my $volume = _get_volume();
  my $muted  = 'No';
  if ($volume >= 128) {
    $muted = 'Yes';
    $volume -= 128;
  }
  say "Volume:  $volume%";
  say "Muted:   $muted";

  my $source_bits = unpack 'B*', substr(_command($GET_SOURCE), 3, 1);
  warn "*** SRC: $source_bits\n" if DEBUG;
  my $power   = substr($source_bits, 0, 1) ? 'Off' : 'On';
  my $inverse = substr($source_bits, 1, 1) ? 'Yes' : 'No';

  my $standby_bits = substr($source_bits, 2, 2);
  my $standby      = 'Unknown';
  if    ($standby_bits eq '00') { $standby = '20 Minutes' }
  elsif ($standby_bits eq '01') { $standby = '60 Minutes' }
  elsif ($standby_bits eq '10') { $standby = 'Never' }

  my $input_bits = substr($source_bits, 4, 4);
  my $input      = 'Unknown';
  if    ($input_bits eq '0010') { $input = 'Wifi' }
  elsif ($input_bits eq '1100') { $input = 'USB' }
  elsif ($input_bits eq '1001') { $input = 'Bluetooth (paired)' }
  elsif ($input_bits eq '1111') { $input = 'Bluetooth (unpaired)' }
  elsif ($input_bits eq '1010') { $input = 'Aux' }
  elsif ($input_bits eq '1011') { $input = 'Optical' }

  say "Source:  $input";
  say "Standby: $standby";
  say "Inverse: $inverse";
  say "Power:   $power";
}

# Usage
else { _usage() }

sub _command {
  my $req = shift;

  state $sock = IO::Socket::INET->new(
    PeerHost => $HOST,
    PeerPort => $port,
    Type     => SOCK_STREAM,
  ) or die "Cannot construct socket: $@";

  warn "*** REQ: @{[unpack 'H*', $req]}\n" if DEBUG;
  $sock->syswrite($req) or die "Cannot write command: $!";
  die "Could not read command response: $!"
    unless defined(my $read = $sock->sysread(my $res, 1024, 0));
  warn "*** RES: @{[unpack 'H*', $res]}\n" if DEBUG;

  return $res;
}

sub _get_volume { unpack 'C', substr(_command($GET_VOLUME), 3, 1) }

sub _set_volume {
  my $volume = shift;
  my $byte   = pack 'C', $volume;
  _command("\x53\x25\x81$byte");
}

sub _usage {
  say <<'EOF';
Usage: kefctl [OPTIONS]

    kefctl --status
    kefctl --volume 70
    kefctl --raise 5
    kefctl --lower 5
    kefctl --off
    kefctl -i optical
    kefctl -i bluetooth -S 20 -I
    kefctl -H 192.168.178.52 -p 50001 -i aux
    kefctl -r 5330819b0b

  Options:
    -h, --help                  Show this summary of available options
    -H, --host <host>           Speaker host, defaults to 192.168.178.42
    -i, --input <source>        Set input source to aux, bluetooth, optical,
                                usb or wifi
    -I, --inverse               Inverse L/R speakers, this option can only be
                                used together with the --input option
    -L, --lower <percentage>    Lower volume by X percent
    -m, --mute                  Mute speakers
    -o, --off                   Turn speakers off, the speakers can be turned
                                back on by setting an input source with the
                                --input option
    -p, --port <port>           Speaker port, defaults to 50001
    -r, --request <hex>         Send raw request in hex format and show response
                                (very useful for testing speaker features)
    -R, --raise <percentage>    Raise volume by X percent
    -s, --status                Show current speaker status
    -S, --standby <minutes>     Set standby time to 20, 60 or 0 (to turn standby
                                off), this option can only be used together with
                                the --input option
    -u, --unmute                Unmute speakers
    -v, --volume <percentage>   Set volume to a percentage value of 0-100, be
                                aware that every input source has its own volume
                                setting
        --version               Show version

  You can also set the KEFCTL_DEBUG environment variable to get diagnostics
  information printed to STDERR.
EOF
}
